#!/usr/bin/env python3
import hashlib
from Crypto.PublicKey import RSA
import sys
import argparse

parser = argparse.ArgumentParser(description="La plupart des appels au ArgumentParserconstructeur \
	utilisent l' description=argument de mot clé. Cet argument donne une brève description de ce \
	que fait le programme et de son fonctionnement. Dans les messages d’aide, la description est\
	 affichée entre la chaîne d’utilisation de la ligne de commande et les messages d’aide des \
	 différents arguments:\
  	 ",
  	 epilog="Une autre description pour le programme")
parser.add_argument("-k", "--keys", dest="keys", help="Pour plus d'informations...")
parser.add_argument("-c", "--copy", dest="copy", help="Pour copier une clé dans la BD")
parser.add_argument("-t", "--taille", dest="taille", help="cette option est obligatoire, elle permet de spécifier la taille de clé en bits.\n Exemple ./module.py 2048")
parser.parse_args()

def generate_keys(bits=2048, private_key_name="private_key.txt", public_key_name="public_key.txt"):



	# if len(sys.argv) < 4:
	# 	print("[-] Utilisation : ./module.py [taille]")
	# 	sys.exit(1)


		

	key  = RSA.generate(bits)

	# Stocke la clé privé dans une variable
	private_key = key.exportKey()

	# Stocke la clé public dans une variable
	public_key = key.publickey().exportKey()

	# Copie la clé privé dans un fichier
	f1 = open(private_key_name, 'wb')
	f1.write(private_key)
	f1.close()

	# Copie la clé public dans un fichier
	f2 = open(public_key_name, 'wb')
	f2.write(public_key)

	# on ferme 
	f2.close()

	return f1,f2

generate_keys()

def generate_hash(filename="toto.txt", returnfile="file_hash.txt"):

	""" Fonction qui calcule le condensé de fichier appelé hash
		En uttilisant l'algorithme de hashage SHA256
	"""
	# inputFile = open(filename, 'w')
	# on ouvre le fichier en lecture seulement
	inputFile = open(filename,'r')

	# on lit tout le fichier et on stocke dans une variable buff
	buff = inputFile.read()

	# on apllique la focntion du hashage SHA26 et on encode en ut8
	hash_file = hashlib.sha256(buff.encode('utf-8'))
	hash_files = hash_file.hexdigest()

	# on ouvre le fichier destination en mode écriture seule
	outFile = open(returnfile,'w')
	
	# on copie tout le fichier haché dans le fichier destination
	outFile.write(hash_files)

	# on ferme les deux fichiers
	inputFile.close()
	outFile.close()

	return outFile



def generate_keys_rsa(bits=2048, ):
    
    # importation des modules neccessaire
    from cryptography.hazmat.backends import default_backend
    from cryptography.hazmat.primitives import serialization
    from cryptography.hazmat.primitives.asymmetric import rsa


    # Generation de nos clés
    key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=bits,
            backend=default_backend()
    )

    # Stockons les clés dans un fichiers
    with open("./keys.pem", "wb") as fichier:
        fichier.write(key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.TraditionalOpenSSL,
            encryption_algorithm=serialization.BestAvailableEncryption(b"passphrase")
        ))
    fichier.close()
    #return key

#generate_keys_rsa()

def generate_certificat_auto_sign(contry_name, city_name, locality_name, organi_name, common_name):

    # importations des modules neccessaires
    from cryptography import x509
    from cryptography.x509.oid import NameOID
    from cryptography.hazmat.primitives import hashes
    from cryptography.hazmat.backends import default_backend
    from cryptography.hazmat.primitives import serialization
    from cryptography.hazmat.primitives.asymmetric import rsa
    import datetime

    
    #from datetime import datetime, timedelta
    # import datetime

    key = generate_keys_rsa()

    # Varialables

    
    # Generation de CSR(Certificate Signing Request)
    # Divers détails sur qui nous sommes. Pour un certificat auto-signé, le sujet et l'émetteur sont toujours les mêmes
    subject = issuer = x509.Name([
        x509.NameAttribute(NameOID.COUNTRY_NAME,  contry_name),
        x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, city_name),
        x509.NameAttribute(NameOID.LOCALITY_NAME, locality_name),
        x509.NameAttribute(NameOID.ORGANIZATION_NAME, organi_name),
        x509.NameAttribute(NameOID.COMMON_NAME, common_name),
    ])

    cert = x509.CertificateBuilder().subject_name(
            subject
    ).issuer_name(
            issuer
    ).public_key(
            key.public_key()
    ).serial_number(
            x509.random_serial_number()
    ).not_valid_before(
            datetime.datetime.utcnow()
    ).not_valid_after(
            # notre certificate sera valide pour 10 jours
            datetime.datetime.utcnow() + datetime.timedelta(days=10)
    ).add_extension(
            x509.SubjectAlternativeName([x509.DNSName(u"localhost")]),
            critical=False,
    # Signer notre certificat avec notre clé privé
    ).sign(key, hashes.SHA256(), default_backend())

    # Stockons le certificat dans un fichier
    with open("cert.pem", "wb") as fichier:
        fichier.write(cert.public_bytes(serialization.Encoding.PEM))

    fichier.close()

    # return fichier

# genrate_certificat_auto_sign()
